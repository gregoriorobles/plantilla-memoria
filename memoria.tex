%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Plantilla de memoria en LaTeX para la EIF - Universidad Rey Juan Carlos
%%
%% Por Gregorio Robles <grex arroba gsyc.urjc.es>
%%     Grupo de Sistemas y Comunicaciones
%%     Escuela de Ingeniería de Fuenlabrada
%%     Universidad Rey Juan Carlos
%% (muchas ideas tomadas de Internet, colegas del GSyC, antiguos alumnos...
%%  etc. Muchas gracias a todos)
%%
%% La última versión de esta plantilla está siempre disponible en:
%%     https://github.com/gregoriorobles/plantilla-memoria
%%
%% Para obtener PDF, ejecuta en la shell:
%%   make
%% (las imágenes deben ir en PNG o JPG)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a4paper, 12pt]{book}
%\usepackage[T1]{fontenc}

\usepackage[a4paper, left=2.5cm, right=2.5cm, top=3cm, bottom=3cm]{geometry}
\usepackage{times}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel} % Comenta esta línea si tu memoria es en inglés
\usepackage{url}
%\usepackage[dvipdfm]{graphicx}
\usepackage{graphicx}
\usepackage{float}  %% H para posicionar figuras
\usepackage[nottoc, notlot, notlof, notindex]{tocbibind} %% Opciones de índice
\usepackage{latexsym}  %% Logo LaTeX

\title{Memoria del Proyecto}
\author{Nombre del autor}

\renewcommand{\baselinestretch}{1.5}  %% Interlineado

\begin{document}

\renewcommand{\refname}{Bibliografía}  %% Renombrando
\renewcommand{\appendixname}{Apéndice}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PORTADA

\begin{titlepage}
\begin{center}
\includegraphics[scale=0.6]{img/URJ_logo_Color_POS.png}

\vspace{1.75cm}

\LARGE
ESCUELA DE INGENIERÍA DE FUENLABRADA
\vspace{1cm}

\LARGE
GRADO EN INGENIERÍA DE TECNOLOGÍAS DE TELECOMUNICACIÓN

\vspace{1cm}
\LARGE
\textbf{TRABAJO FIN DE GRADO}

\vspace{2cm}

\Large
EVOLUCIÓN DE LA PARTICIPACIÓN VOLUNTARIA DE PROYECTOS DE SOFTWARE LIBRE:
EVIDENCIAS DE DEBIAN

\vspace{2cm}

\large
Autor : Pablo Cabeza Portalo \\
Tutor : Dr. Gregorio Robles\\

\vspace{1cm}

\large
Curso académico 2023/2024

\end{center}
\end{titlepage}

\newpage
\mbox{}
\thispagestyle{empty} % para que no se numere esta pagina



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Para firmar
\clearpage
\pagenumbering{gobble}
\chapter*{}

\vspace{-4cm}
\begin{center}
\LARGE
\textbf{Trabajo Fin de Grado}

\vspace{1cm}
\large
Evolución de la Participación Voluntaria en Proyectos de Software Libre:
Evidencia de Debian

\vspace{1cm}
\large
\textbf{Autor :} Pablo Cabeza Portalo \\
\textbf{Tutor :} Dr. Gregorio Robles

\end{center}

\vspace{1cm}
La defensa del presente Proyecto Fin de Carrera se realizó el día \qquad$\;\,$ de \qquad\qquad\qquad\qquad \newline de 2024, siendo calificada por el siguiente tribunal:


\vspace{0.5cm}
\textbf{Presidente:}

\vspace{1.2cm}
\textbf{Secretario:}

\vspace{1.2cm}
\textbf{Vocal:}


\vspace{1.2cm}
y habiendo obtenido la siguiente calificación:

\vspace{1cm}
\textbf{Calificación:}


\vspace{1cm}
\begin{flushright}
Fuenlabrada, a \qquad$\;\,$ de \qquad\qquad\qquad\qquad de 2024
\end{flushright}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Dedicatoria

\chapter*{}
\pagenumbering{Roman} % para comenzar la numeracion de paginas en numeros romanos
\begin{flushright}
\textit{Dedicado a \\
mi familia, mis amigos y a mi pareja.}
\end{flushright}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Agradecimientos

\chapter*{Agradecimientos}
%\addcontentsline{toc}{chapter}{Agradecimientos} % si queremos que aparezca en el índice
\markboth{AGRADECIMIENTOS}{AGRADECIMIENTOS} % encabezado 

Este es el fin de una de las etapas más importantes de mi vida y por ello quiero agradecer a varias personas que me han acompañado en este proceso.
Primero quiero agradecer a mi madre Antonia todo el apoyo que me ha dado en cada una de mis decisiones, tanto personales como académicas. Eres quien me impulsa a lograr mis sueños.
Segundo a mi padre Manuel que siempre ha sido mi ejemplo a seguir. Me ha aportado valores fundamentales como el trabajo y el esfuerzo que han sido imprescindibles para abordar esta carrera.
Gracias a los dos por darme la vida.
También agradecer a mi tutor, Gregorio, por darme este proyecto, tener paciencia  y ayudarme en todo cuanto pudo para desarrollarlo.
Por último, quiero agradecer a esa persona tan especial que conocí en esta universidad y que me dio la confianza y la fuerza necesaria para lograr mis metas. 
Paula, gracias por ser mi compañera de viaje y por aparecer en el momento que mas lo necesitaba. Hemos afrontado este desafío juntos y sin ti no hubiera sido igual.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Resumen

\chapter*{Resumen}
%\addcontentsline{toc}{chapter}{Resumen} % si queremos que aparezca en el índice
\markboth{RESUMEN}{RESUMEN} % encabezado

Aquí viene un resumen del proyecto.
Ha de constar de tres o cuatro párrafos, donde se presente de manera clara y concisa de qué va el proyecto. 
Han de quedar respondidas las siguientes preguntas:

\begin{itemize}
  \item ¿De qué va este proyecto? ¿Cuál es su objetivo principal?
  \item ¿Cómo se ha realizado? ¿Qué tecnologías están involucradas?
  \item ¿En qué contexto se ha realizado el proyecto? ¿Es un proyecto dentro de un marco general?
\end{itemize}

Lo mejor es escribir el resumen al final.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Resumen en inglés

\chapter*{Summary}
%\addcontentsline{toc}{chapter}{Summary} % si queremos que aparezca en el índice
\markboth{SUMMARY}{SUMMARY} % encabezado

Here comes a translation of the ``Resumen'' into English. 
Please, double check it for correct grammar and spelling.
As it is the translation of the ``Resumen'', which is supposed to be written at the end, this as well should be filled out just before submitting.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ÍNDICES %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Las buenas noticias es que los índices se generan automáticamente.
% Lo único que tienes que hacer es elegir cuáles quieren que se generen,
% y comentar/descomentar esa instrucción de LaTeX.

%%%% Índice de contenidos
\tableofcontents 
%%%% Índice de figuras
\cleardoublepage
%\addcontentsline{toc}{chapter}{Lista de figuras} % para que aparezca en el indice de contenidos
\listoffigures % indice de figuras
%%%% Índice de tablas
%\cleardoublepage
%\addcontentsline{toc}{chapter}{Lista de tablas} % para que aparezca en el indice de contenidos
%\listoftables % indice de tablas


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% INTRODUCCIÓN %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Introducción}
\label{sec:intro} % etiqueta para poder referenciar luego en el texto con ~\ref{sec:intro}
\pagenumbering{arabic} % para empezar la numeración de página con números

Vivimos en un mundo totalmente digitalizado en el que la presencia de ordenadores está a la orden del día. Con esto no nos referimos únicamente a ordenadores de escritorio. A diario interactuamos con una amplia gama de dispositivos compuestos por ordenadores camuflados. Desde electrodomésticos inteligentes pasando por coches modernos hasta en tarjetas de crédito. Estos tienen incorporados ordenadores pequeños pero potentes que realizan una serie de tareas para el beneficio y la mejora de la vida humana.

En la mayoría de estos ordenadores de uso cotidiano, como portátiles o móviles, se aloja un Sistema Operativo. Un Sistema Operativo es el “intermediario” entre el usuario y el hardware del ordenador a partir de software. Gestiona los recursos del hardware proporcionando una interfaz al usuario. De esta forma pueden interactuar con dicho ordenador. 
Algunos de los sistemas operativos más usados son: iOS, Android, macOS, Microsoft Windows o Linux. 

Linux es un sistema operativo de código abierto el cual es gratuito para cualquier usuario que quiera adoptarlo en su computadora. Este consta de muchas distribuciones. Las distribuciones son versiones del Sistema Operativo de Linux desarrolladas por diferentes individuos, equipos o empresas para mejorar la experiencia de los usuarios.

Una de estas distribuciones es “Debian” y es sobre la que tratará este estudio.
Debian es un Sistema Operativo que trabaja con el Kernel (núcleo) de Linux y ha ido aportando distintas versiones desde 1993. 
Treinta años después nos preguntamos ciertas cosas como, ¿Los individuos que trabajaban en las primeras versiones siguen actualizando Debian? ¿Se trabaja individualmente o por equipos? ¿Cuántos paquetes sacan en cada versión? ¿Qué ocurre con ellos? Todo esto lo veremos a continuación.



\section{Contexto}
\label{sec:contexto}



\subsection{Proyecto Debian}
\label{subsec:proyecto debian}

El Proyecto Debian está formado por un grupo de voluntarios a nivel mundial que trabajan para producir una distribución del Sistema Operativo Linux basada en "software libre".

Con el término "software libre" no nos referimos a su coste. Este va enfocado a la "libertad real" dentro del software, es decir, "software de código abierto".
Esto significa que cualquier usuario puede acceder al código fuente para estudiarlo, revisarlo, modificarlo o distribuirlo sin restricción alguna.

Debian es la distribución de Linux más relevante sin fines comerciales.
En su comienzo, fue la única abierta a la participación de diferentes usuarios que quisieran aportar al proyecto con su trabajo.

Con el tiempo fue asentando un gran conjunto de directrices y procedimientos para el empaquetamiento y distribución de software. Esto les sirvió para poder alcanzar los estándares de calidad requeridos y con ello asegurar su buen funcionamiento.

\subsection{Versiones Debian}
\label{subsec:versiones debian}

Debian está conformado por varias versiones desde 1993 las cuales explicaremos a continuación:

\begin{itemize}

	\item \textbf {Versiones 0.x (1993 - 1995):} estas versiones fueron las primeras y mas rudimentarias pero dieron lugar a la creación de Debian gracias a su creador \textbf {Ian Murdock}.
	\begin{itemize}
		\item \textbf {Debian 0.01 hasta 0.90.}
		\item \textbf {Debian 0.91:} disponía de un sencillo sistema de empaquetamiento que permitía instalar y desinstalar paquetes.
		\item \textbf {Debian 0.93R5:}  se asignaron responsabilidades de cada paquete a cada uno de los desarrolladores. Se comenzo a usar el administrador de paquetes \textbf {dpkg} para la instalación de paquetes después de la instalación del sistema.
		base.
	\end{itemize}
	\item \textbf {Versiones 1.x (1996 - 1997):} \textbf{Bruce Perens} fue designado como líder del proyecto después de que Ian lo designara.
	\begin{itemize}
		\item \textbf {Debian 1.0:} esta versión nunca fue publicada debido a una confusión al distribuir una versión en desarrollo con el nombre equivocado de Debian 1.0 que daría problemas en ejecución.
		\item \textbf {Debian 1.1 Buzz: } es la primera versión de Debian con un nombre en clave sacado de las peliculas de \textbf {"Toy Story"}.
		\item \textbf {Debian 1.2 Rex: } esta versión estaba completamente en formato \textbf{ELF} y usaba el núcleo (kernel) Linux 2.0.
		
		El formato \textbf{ELF} (Executable and Linkable Format) es un estándar. Se usa en sistemas operativos tipo \textbf{UNIX} (como Linux). Sirve para organizar y manejar archivos ejecutables, bibliotecas compartidas y otros objetos binarios.
		\item \textbf {Debian 1.3 Bo}.
	\end{itemize}
	\item \textbf {Versiones 2.x (1998 - 2000):} \textbf{Ian Jackson} pasó a ser el líder del proyecto.
	\begin{itemize}
		\item \textbf {Debian 2.0 Hamm: }fue la primera versión multiplataforma de Debian. Agregó soporte para arquitecturas de la serie \textbf{Motorola 68000}.
		\item \textbf {Debian 2.2 Potato: }agregó soporte para las arquitecturas  PowerPC y ARM (CPU's de arquitectura RISC creadas por diferentes empresas).
	\end{itemize}
	\item \textbf {Versiones 3.x (2002 -2005):}
	\begin{itemize}
		\item \textbf {Debian 3.0 Woody: }se agregaron más arquitecturas a esta versión y fue la primera en usar \textbf {software criptográfico}. Este se usa para codificar información y mantener la transferencia segura de datos.
		\item \textbf {Debian 3.1 Sarge: }incluye un nuevo instalador llamado \textbf {debian-installer}. Contiene detección automática de hardware, instalación sin supervisión y está traducido a más de treinta idiomas.
	\end{itemize}
	\item \textbf {Debian 4.0 Etch (2007):}se añadieron mejoras como un instalador gráfico o la verificación criptográfica de los paquetes descargados entre otras.
	\item \textbf {Debian 5.0 Lenny (2009):}añadió la arquitectura \textbf {ARM EABI} para dar soporte a los nuevos procesadores \textbf {ARM}.
	\item \textbf {Debian 6.0 Squeeze: }con esta versión fue la primera vez que una distribución de Linux se extendía para permitir también el uso de un núcleo no Linux.
	\item \textbf {Debian 7.0 Wheezy (2011):}se introdujo el soporte de \textbf {multiarquitectura}. Esto permitía que los usuarios instalaran en una misma máquina paquetes de múltiples arquitecturas.
	\item \textbf {Debian 8 Jessie (2013):}trajo importantes mejoras de seguridad, como un nuevo kernel que solucionaba varias vulnerabilidades (como \textbf {ataques de enlace simbólico}).
	\item \textbf {Debian 9 Stretch (2015):}se introdujeron paquetes para la depuración a través de un repositorio nuevo en el archivo. Facilitaría el proceso de depuración y solución de problemas relacionados con esos paquetes.
	\item \textbf {Debian 10 Buster (2019):} incluyó por primera vez un marco de control de acceso obligatorio. Restringe las acciones que pueden realizar los programas, limitando su acceso a ciertos recursos del sistema, como archivos, directorios, redes, etc.
	\item \textbf {Debian 11 Bullseye (2021):} introduce un nuevo paquete, ipp-usb, que utiliza el protocolo IPP-over-USB, independiente del fabricante y soportado por muchas impresoras actuales. Esto permite que un dispositivo USB sea tratado como un dispositivo de red.
	
		
\end{itemize}
	


\section{Estructura de la memoria}
\label{sec:estructura}

A continuación se exponen los capítulos en los que se organiza esta memoria y los puntos clave tratados en cada uno de ellos:


\begin{itemize}
  \item \textbf {Capítulo 1: Introducción.} Se explica el contexto de Debian y las diferentes versiones distribuidas a lo largo de su historia.
  
  \item \textbf {Capítulo 2: Objetivos.} Se especifica cuales son los objetivos parciales para lograr el objetivo general.
  
  \item \textbf {Capítulo 3: Estado del arte.} Se muestran y explican las diferentes tecnologías usadas para la realización de dicho proyecto.
  
  \item \textbf {Capítulo 4: Diseño e implementación.} Se muestran las diferentes etapas que se han seguido en este proyecto a detalle.
  
  \item \textbf {Capítulo 5: Experimentos y validación.} Se indica el proceso seguido para alcanzar los diferentes objetivos usando diferentes tecnologías.
  
  \item \textbf {Capítulo 6: Resultados.} Se muestran los diferentes resultados de estos experimentos. También se comentan los diferentes patrones o tendencias procedentes del análisis de dichos resultados.
  
  \item \textbf {Capítulo 7: Conclusiones.} Se observan los resultados obtenidos y se comparan con lo que se esperaba obtener. Se realizan una serie de deducciones tras el tratamiento y el análisis de los datos. Se aplican los conocimientos adquiridos en la carrera y se plantean nuevas lineas de investigación.
  
\end{itemize}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% OBJETIVOS %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage % empezamos en página impar
\chapter{Objetivos} % título del capítulo (se muestra)
\label{chap:objetivos} % identificador del capítulo (no se muestra, es para poder referenciarlo)



\section{Objetivo general} % título de sección (se muestra)
\label{sec:objetivo-general} % identificador de sección (no se muestra, es para poder referenciarla)

Este proyecto de fin de grado se basa en el análisis de los lanzamientos, paquetes y mantenedores presentes en la evolución de la distribución Debian a lo largo de su historia. 

Se busca conocer, de cada lanzamiento (\textbf{release}), la evolución en el número de personas y equipos que lo mantienen,  cuantos de ellos siguen en releases posteriores y que ocurre con los paquetes de un mantenedor si este abandona el proyecto. Se ha podido llevar acabo gracias al estudio de diferentes paquetes de datos aportados por Debian\footnote{\url{https://www.debian.org/releases/}} en su página oficial.
De esta forma obtenemos las diferencias y similitudes necesarias para la comparación de los releases de forma que podamos comprender su evolución.


\section{Objetivos específicos}
\label{sec:objetivos-especificos}

Para poder llevar a cabo dicho objetivo se requiere: 

\begin{itemize}
	\item \textbf {Diseño del diagrama entidad relación.} Comprender los diferentes campos que conforman un paquete y crear un diagrama para el posterior diseño de la base de datos que los alojará.
	.
	\item \textbf {Creación de la base de datos.} Crear una base de datos con un buen diseño (basada en el diagrama anterior) para poder lanzar \textbf {Query´s} con las que obtener la información que se requiere.
	
	\item \textbf {Formulación de Query´s.} Analizar la información que queremos extraer de la base de datos y crear las llamadas necesarias para obtenerla.
	
	
	\item \textbf {Creación de tablas y gráficas.} Con la información obtenida se crean diferentes tablas y gráficas para ayudar a la comprensión de los datos de forma visual.
\end{itemize}


\section{Planificación temporal}
\label{sec:planificacion-temporal}

En el Diagrama de la Figura~\ref{fig:diagrama_gantt} se visualizan las diferentes tareas realizadas junto con la organización en días de las mismas. 

Primero se marcaron los objetivos junto con las tecnologías a usar en este proyecto.
Más tarde se realizó un análisis de los diferentes paquetes para poder crear el diagrama, el diseño de la base de datos y sus tablas correspondientes.
Realizamos el parseo de las diferentes datos del paquete para poder insertarlos correctamente en la base de datos.
La inserción de los datos fue lo más problemático en este proyecto. Cada release consta de muchos paquetes en los cuales hay que parsear, extraer e insertar todos los datos. Este estudio se realiza sobre 11 releases. Al tratarse de tanto volumen de datos, el tiempo de ejecución fue elevado. Al comprobar las bases de datos y hallar errores, se insertaban de nuevo los datos por lo que esto fue lo más complejo del proyecto.

Finalmente se realizaron una serie de llamadas sql (Query´s) con las que extraer la información necesaria para el proyecto junto con sus gráficas para obtener dicha información de forma visual.

Con ello pudimos obtener conclusiones sobre el estudio de estos datos y comenzar con la redacción de la memoria.

Dr. Gregorio Robles me propuso dicho proyecto en noviembre de 2023 y el tiempo desempeñado en él ha sido de 4h diarias reflejadas en los días laborales, de lunes a viernes. En los meses de abril y mayo se intensifico mi desempeño a 6h diarias para desarrollar la memoria con la mayor dedicación posible.

\begin{figure}
	\centering
	\includegraphics[width=9cm, keepaspectratio]{img/Gantt.png}
	\caption{Diagrama de Gantt}
	\label{fig:diagrama_gantt}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ESTADO DEL ARTE %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Estado del arte}
\label{chap:estado}


\section{Python 3.12.0} 
\label{sec:python}
\textbf{Python}~\cite{oracle:_python} es un lenguaje de programación orientado a objetos de alto nivel con una sintaxis fácil de interpretar y leer. Tiene un amplio uso en computación científica, desarrollo web y automatización.

\textbf{Peter Norvig}, director de investigación de Google afirma que "Python ha sido una parte importante de Google desde el principio, y permanece así a medida que el sistema crece y evoluciona".

Al ser un lenguaje popular tiene una mayor selección de bibliotecas, lo que ahorra a un desarrollador cantidades increíbles de tiempo y esfuerzo. También tiene más tutoriales y documentación. Esto aumenta las probabilidades de encontrar soluciones a los problemas.

Una curiosidad del lenguaje es que la empresa de mayor emprendimiento de la "inteligencia artificial"  \textbf{ Open AI\footnote{\url{https://platform.openai.com/docs/libraries/python-library}}} está diseñada con python en gran parte y sus bibliotecas son públicas para su uso.

En la figura~\ref{fig:evolucion_python} podemos observar que Python es el lenguaje más usado del mundo según sus últimos datos en 2019~\cite{statista:_tecnología}.

\begin{figure}
	\centering
	\includegraphics[width=14cm, keepaspectratio]{img/ev_python.jpeg}
	\caption{Lenguajes de programación más populares del mundo}
	\label{fig:evolucion_python}
\end{figure}

\section{My sql connector} 
\label{sec:mysqlconnector}
Esta es la librería más importante de Python para poder desarrollar este proyecto.
MySQL Connector/Python~\cite{mysql:_connectors} permite a los programas de Python acceder a las bases de datos MySQL, utilizando una API que cumple con la Especificación de API de Base de Datos de Python.
Sus funciones más destacadas e importantes son:
\begin{enumerate}
	\item \textbf{Conexión a la base de datos: }con la función \textbf{mysql.connector.connect().}
	\item \textbf{Ejecución de consultas SQL: }con la función \textbf{cursor.execute().}
	\item \textbf{Recuperación de resultados: }con la función \textbf{cursor.fetchall()}.
	\item \textbf{Inserción, actualización y eliminación de datos: }con consultas SQL como INSERT, UPDATE y DELETE, ejecutadas con la función \textbf{cursor.execute().}
	\item \textbf{Gestión de errores: }se capturan y manejan errores en el código Python usando excepciones.
	\item \textbf{Desconexión de la base de datos: }con la función \textbf{connection.close().}
\end{enumerate}

\section{Matplotlib} 
\label{sec:matplotlib}


Matplotlib es~\cite{python:_matplotlib} es una librería de \textbf{Python open source}. John Hunter, neurobiólogo, fue su desarrollador inicial en 2002. Su objetivo era visualizar las señales eléctricas del cerebro de personas epilépticas. Por ello intentó replicar las diferentes funcionalidades de MATLAB (gráficas) con Python. 

Matplotlib ha sido mejorado a lo largo del tiempo por numerosos contribuidores de la comunidad open source. Se usa para crear gráficas y diagramas de gran calidad que aportan la visualización de los datos de  forma detallada.

Es posible crear trazados, histogramas, diagramas de barras y cualquier tipo de gráfica como en la Figura ~\ref{fig:matplotlib} con unas lineas de código.

Esta librería es particularmente útil para las personas que trabajan con Python o NumPy.

\begin{figure}[hb]
	\centering
	\includegraphics[width=14cm, keepaspectratio]{img/Matplotlib.png}
	\caption{Ejemplos gráficas Matplotlib}
	\label{fig:matplotlib}
\end{figure}

\section{Pycharm} 
\label{sec:pycharm}

PyCharm es el \textbf{IDE}~\cite{python:_pycharm} más popular para Python hasta la fecha. Esta plataforma híbrida se utiliza habitualmente para el desarrollo de aplicaciones en Python por grandes empresas como Twitter, Facebook, Amazon y Pinterest.

Un \textbf{Integrated Development environment (IDE)} o \textbf{Entorno de Desarrollo Integrado (EDI)} es un conjunto de herramientas necesarias para desarrollar software. Incluye un editor y un compilador.


Pycharm es compatible con Windows, Linux y macOS. Además contiene módulos y paquetes que ayudan a los desarrolladores a programar software con Python más rápido y con menos esfuerzo y se puede personalizar para responder a las necesidades específicas de un proyecto.

\begin{figure}[hb]
	\centering
	\includegraphics[width=14cm, keepaspectratio]{img/pycharm.png}
	\caption{Pycharm}
	\label{fig:pycharm}
\end{figure}

\section{SQL} 
\label{sec:sql}
Es un lenguaje de programación que \textbf{almacena y procesa información en una base de datos relacional}. 

Una base de datos \textbf{relacional} almacena información en forma de tabla, con filas y columnas que representan diferentes atributos de datos junto con sus relaciones. Con ello se puede \textbf{almacenar, actualizar, eliminar, buscar y recuperar} información de la base de datos.

Es un lenguaje de consulta popular que se usa con frecuencia en todos los tipos de aplicaciones debido a su alta integración con el resto de lenguajes tales como \textbf{java, python, C\#, PHP, etc}.

\section{MySQL WorkBench} 
\label{sec:mysqlworkbench}

Es una herramienta visual ideal para \textbf{modelar, diseñar y administrar bases de datos MySQL} junto con el uso de código MySQL.

Se trata de una herramienta gráfica que fue creada por la compañía Oracle.
Es un programa de cliente que, a través de un entorno de desarrollo integrado, facilita la creación, consulta y administración de bases de datos~\cite{mysql:_workbench}. 

Este software tiene múltiples funcionalidades como:
\begin{itemize}
	\item \textbf {Modelado de datos}: diseñar, modelar, gestionar y generar bases de datos de forma visual. 
	\item \textbf {Ingeniería inversa}: recopilar información o datos a partir de un producto determinado para saber qué elementos lo componen. 
	\item \textbf {Migrar bases de datos}: migrar desde Microsoft SQL Server, Microsoft Access, Sybase ASE y otros sistemas de gestión de bases de datos a MySQL.
\end{itemize}

\begin{figure}[hb]
	\centering
	\includegraphics[width=10cm, keepaspectratio]{img/workbench.png}
	\caption{SQL Workbench}
	\label{fig:workbench}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DISEÑO E IMPLEMENTACIÓN %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Diseño e implementación}
\label{sec:diseno}

\section{Arquitectura general} 
\label{sec:arquitectura}
El objetivo es descubrir e investigar como evoluciona la distribución de Debian a lo largo de su historia y los factores que han cambiado o se han mantenido en releases posteriores junto con su explicación. Para ello hemos seguido estas fases:
\begin{figure}[h]
	\centering
	\includegraphics[width=14cm, keepaspectratio]{img/Diagrama_general.png}
	\caption{Fases del tratamiento de datos}
	\label{fig:Diagrama_general}
\end{figure}

Debemos analizar una gran cantidad de datos. Debian consta de 11 releases (lanzamientos) en los cuales se hallan un gran volumen de paquetes que va aumentando exponencialmente en releases posteriores.

Por ello, se necesita seguir una secuencia específica representada en la \textbf {Figura~\ref{fig:Diagrama_general}} para descargar, limpiar, ordenar y extraer estos datos de forma efectiva. 

Primero debemos descargar los diferentes releases de Debian desde su página oficial~\cite{oficialdebian:_releases}.
Con ello ya podremos analizar los diferentes paquetes que contienen y así poder diseñar el diagrama entidad - relación correspondiente.

Una vez tenemos el diseño completo, podremos comenzar con la creación de las diferentes BBDD (bases de datos) tal que cada release sea una BBDD con sus correspondientes tablas sql.

En este punto creamos un script cuya funcionalidad será parsear los diferentes paquetes de cada release con el fin de extraer la información necesaria.

Una vez extraída dicha información creamos otro script que, conectándose a la BBDD correspondiente, introduzca los datos parseados en la BBDD para su posterior análisis.

Se crean una serie de Query´s o llamadas sql para poder obtener la información que necesitamos y así responder a los intereses del proyecto.

Por último, creamos una serie de gráficas y tablas para ayudar a la visualización de los resultados obtenidos en este estudio.


\section{Descarga de los releases de Debian} 
\label{sec:Descarga_de_los_releases_de_Debian}

Esta fase es la más rápida. Conociendo las páginas donde encontrar los releases retirados~\cite{debian:_releases_archive} y los que siguen en uso ~\cite{debian:_releases} (aportados por mi tutor Gregorio), podemos descargar sus diferentes archivos \textbf{main} donde encontramos todos los paquetes de cada lanzamiento y con ello los datos que queremos tratar.

\begin{figure}[h]
	\centering
	\includegraphics[width=10cm, keepaspectratio]{img/releases.png}
	\caption{Descarga de los datos de releases}
	\label{fig:Descarga_releases}
\end{figure}

\section{Análisis de los paquetes de cada release} 
\label{sec:analisis_de_los_paquetes}

En esta fase se requiere un estudio detallado de los diferentes atributos de cada paquete. Asignamos las entidades y las relaciones existentes entre los mismos para poder construir un diagrama valido para el diseño de las bases de datos posteriores.

Un paquete esta conformado por los atributos mostrados en la \textbf {Figura~\ref{fig:paquete}}.

\begin{figure}[h]
	\centering
	\includegraphics[width=15cm, keepaspectratio]{img/paquete.png}
	\caption{Atributos de un paquete.}
	\label{fig:paquete}
\end{figure}

El siguiente proceso consta de la comparación de diferentes paquetes para entender que entidades hay y como relacionarlas:

\begin{itemize}
	\item \textbf {Package nombre}: siempre hay 1 y es único. 
	\item \textbf {Binary}: mínimo hay 1 o más. 
	\item \textbf {Version}: siempre hay 1 y puede repetirse en varios paquetes.
	\item \textbf {Maintainer}: siempre hay 1 y puede repetirse en varios paquetes. 
	\item \textbf {Uploaders}: mínimo hay 1 o más y puede repetirse en varios paquetes. 
	\item \textbf {Build-Depends}: mínimo hay 1 o más y puede repetirse en varios paquetes.  
	\item \textbf {Architecture}: siempre hay 1 y puede repetirse en varios paquetes. 
	\item \textbf {Standards-Version}: siempre hay 1 y puede repetirse en varios paquetes.
	\item \textbf {Format}: siempre hay 1 y puede repetirse en varios paquetes. 
	\item \textbf {Files}:  mínimo hay 1 o más y son únicos. 
	\item \textbf {Vcs-Browser}: (no está en todos los paquetes) siempre hay 1 y es único. 
	\item \textbf {Vcs-Git}: (no está en todos los paquetes) siempre hay 1 y es único. 
	\item \textbf {Checksums-Sha256}: mínimo hay 1 o más y son únicos. 
	\item \textbf {Homepage}: (no está en todos los paquetes) siempre hay 1 y puede repetirse en varios paquetes. 
	\item \textbf {Package-List}: mínimo hay 1 o más y son únicos. 
	\item \textbf {Directory}: siempre hay 1 y es único. 
	\item \textbf {Dgit}: (no está en todos los paquetes) siempre hay 1 y es único. 
	\item \textbf {Testsuite}: (no está en todos los paquetes) siempre hay 1 y puede repetirse en varios paquetes. 
	\item \textbf {Testsuite-Triggers}: (no está en todos los paquetes) mínimo hay 1 o más y puede repetirse en varios paquetes. 
	\item \textbf {Priority}: siempre hay 1 y puede repetirse en varios paquetes. 
	\item \textbf {Section}: siempre hay 1 y puede repetirse en varios paquetes. 
\end{itemize}

Con esta información podemos comenzar con el diseño del diagrama.

\section{Creación diagrama Entidad - Relación} 
\label{sec:diagrama_entidad_relacion}
Un diagrama \textbf {entidad-relación}, también conocido como \textbf {modelo entidad relación o ERD ~\cite{lucidchart:_diagramaERD}}, es un tipo de diagrama de flujo que ilustra cómo las entidades, como personas, objetos o conceptos, se relacionan entre sí dentro de un sistema.

Los diagramas ER se usan a menudo para diseñar o depurar bases de datos relacionales en los campos de ingeniería de software, sistemas de información empresarial, educación e investigación. También emplean un conjunto definido de símbolos, tales como rectángulos, diamantes, óvalos y líneas de conexión para representar la interconexión de \textbf {entidades, relaciones y sus atributos.}

En la Figura ~\ref{fig:entidad_relación} se observa el diseño del diagrama junto con la Figura ~\ref{fig:leyenda_diagrama} que es su leyenda.

\begin{figure}[h]
	\centering
	\includegraphics[width=17cm, keepaspectratio]{img/diagrama_entidad_relación.png}
	\caption{Diagrama ERD.}
	\label{fig:entidad_relación}
\end{figure}

\begin{figure}[h]
	\centering
	\includegraphics[width=10cm, keepaspectratio]{img/Leyenda_diagrama.png}
	\caption{Leyenda de diagrama ERD.}
	\label{fig:leyenda_diagrama}
\end{figure}

Cada rectángulo es una entidad que va unida a otras entidades mediante una serie de líneas y el rombo que las separa es el indicador del tipo de relación que muestran.

En este caso todas las entidades tienen una relación de pertenencia debido a que un paquete contiene o no estas entidades.

En la \textbf {Figura ~\ref{fig:leyenda_diagrama}} podemos ver el tipo de relación entre entidades:

\begin{itemize}
\item \textbf {1: }esta línea discontinua muestra una relación de \textbf {0 a infinito}, es decir, pueden existir ninguna, una o muchas entidades en el paquete.
\item \textbf {2: }esta línea continua muestra una relación de \textbf {1 a infinito}, es decir, pueden existir una o muchas entidades en el paquete pero nunca puede no existir.
\item \textbf {3: }esta línea discontinua terminada en flecha muestra una relación de \textbf {0 a 1}, es decir, pueden existir ninguna o una entidad en el paquete.
\item \textbf {4: }esta línea continua terminada en flecha muestra una relación de \textbf {1 a 1}, es decir, solo puede existir una entidad en el paquete obligatoriamente.
\end{itemize}

Una vez completadas las relaciones junto con las entidades se diseña la BBDD que va a acoger todos aquellos datos necesarios para el estudio.

\section{Creación de BBDD junto con tablas SQL} 
\label{sec:creacion_BBDD}
En este punto se usan las aplicaciones MySQL Workbench y Pycharm.

Se crean las diferentes BBDD en MySQL para poder realizar la inserción de las tablas posteriormente como se muestra en la \textbf {Figura ~\ref{fig:BBDDsql}}.

\begin{figure}[h]
	\centering
	\includegraphics[width=2cm, keepaspectratio]{img/BBDDsql.png}
	\caption{Bases de datos}
	\label{fig:BBDDsql}
\end{figure}

El diseño de la BBDD depende directamente del diagrama realizado anteriormente. 
Este diagrama tiene una traducción a lenguaje sql:
\begin{itemize}
	\item \textbf {Entidad 1 (flecha hacia) Entidad 2}: cuando esto ocurre necesitamos crear una \textbf {foreing key} para relacionar las tablas de cada entidad. \textbf {Entidad 1} debe tener una foreing key para la \textbf {Entidad 2}.
	
	\begin{verbatim}
		"""
		CREATE TABLE IF NOT EXISTS package_list (
		id INT AUTO_INCREMENT PRIMARY KEY,
		nombre VARCHAR(255) NOT NULL UNIQUE,
		package_id INT NOT NULL,
		FOREIGN KEY (package_id) REFERENCES package(id)
		)
		"""
	\end{verbatim}
	
	Una \textbf {FOREIGN KEY} ~\cite{thedataschool:_foreingkey} en SQL, es una clave (campo de una columna) que sirve para relacionar dos tablas. El campo FOREIGN KEY se relaciona o vincula con la PRIMARY KEY de otra tabla de la bbdd.
	
	La restricción \textbf {PRIMARY KEY}~\cite{thedataschool:_primarykeyen} SQL identifica de forma única cada registro en una tabla.
	Deben contener valores únicos y no pueden contener valores NULL.
	Una tabla solo puede tener una clave principal, que puede consistir en campos simples o múltiples.
	
	\item \textbf {{Entidad 1 (linea) Entidad 2}}: en este caso no tenemos claro que entidad debría acoger la foreing key por lo que se crea una tabla intermedia.
	Esta tabla constará de los identificadores de cada tabla como sus primary key.
	En ella es en la que se definirán las foreing key hacia ambas tablas y así poder relacionarlas.
	
	\begin{verbatim}
	"""
	CREATE TABLE IF NOT EXISTS uploaders_package (
	package_id INT NOT NULL,
	uploaders_id INT NOT NULL,
	PRIMARY KEY (package_id, uploaders_id),
	FOREIGN KEY (package_id) REFERENCES package(id),
	FOREIGN KEY (uploaders_id) REFERENCES uploaders(id)
	)
	"""
	\end{verbatim}
	
	Finalmente, se procede al desarrollo de un script que se conecte a la BBDD para crearlas y comenzar a usarlas.
	
	Para ello, debemos establecer una conexión con la BBDD indicando el host, puerto, usuario, contraseña y nombre de la BBDD.
	
	Todo se realiza a través de python y con la librería mysql.connector.
	
	\begin{figure}[h]
		\centering
		\includegraphics[width=3.5cm, keepaspectratio]{img/Tablas.png}
		\caption{Tablas BBDD}
		\label{fig:Tablas}
	\end{figure}

	
\end{itemize}

\section{Parseo de la información de los paquetes} 
\label{sec:parseo}
Tras la creación de las diferentes BBDD con sus tablas correspondientes, ahora debemos enfocarnos en obtener la información de interés para introducirla en dichas tablas SQL.

Para ello se diseña un script en Pycharm siguiendo estos pasos:

\begin{enumerate}
	\item \textbf{Lectura del archivo.} Las descargas de los releases realizadas en la sección  ~\ref{sec:Descarga_de_los_releases_de_Debian} las tratamos como ficheros de texto. Por ello debemos leer linea por linea todo el fichero e ir guardando la información relevante de cada paquete.
	
	\begin{verbatim}
		with open('Sources/14.Sources - bookworm-main.txt', 'r', encoding='utf-8') as file:
		lines = iter(file.readlines())
	\end{verbatim}
	
	\item \textbf{Especificar que datos son relevantes.} Se crea un array de strings con los diferentes nombres de los campos que queremos sacar para verificar si alguno se encuentra en la línea en la que estamos leyendo.
	
	\begin{verbatim}
		array_items = ['Package', 'Binary', 'Version', 'Maintainer', 'Uploaders', 'Build-Depends', 'Architecture',
		'Standards-Version', 'Format', 'Files', 'Vcs-Browser', 'Vcs-Git', 'Checksums-Sha256', 'Homepage',
		'Package-List', 'Directory', 'Priority', 'Section', 'Testsuite', 'Testsuite-Triggers']
	\end{verbatim}
	
	\item \textbf{Buscar los datos relevantes en el archivo.} Con el diseño del array ya podemos encontrar la información de interés. Recorremos línea a línea el archivo, comparamos si esa línea empieza con alguno de los items definidos seguido de \textbf{:} y parseamos la información guardándola en unas variables definidas anteriormente.
	
	\begin{verbatim}
		for line in lines:
		field, *value = map(str.strip, line.split(': ', 1))
		value = value[0] if value else ''
		
		if field in array_items:
	
			if field == "Package":
				package = value
			
			elif field == "Binary":
				binary = value
			...
	\end{verbatim}
	
		\item \textbf{Identificar el final del paquete.} En un archivo hay miles de paquetes juntos separados por una línea en blanco. Este será nuestro identificador de que hemos recogido la información de un paquete. Si encuentra dicha línea, se llama a la función que nos permitirá insertar esta información en las diferentes tablas.
		
	\begin{verbatim}
		 elif not line.strip():
		# Esto indica el final de la información del paquete
			insertar_info(package, binary, version, maintainer, uploaders, build_depends, architecture,
			standards_version, format1, files_list, vcs_browser, vcs_git, check_list, homepage,
			package_list, directory, priority, section, testsuite, testsuite_triggers)
	\end{verbatim}
	
		\item \textbf{Restaurar las variables.} Este proceso es iterativo debido a que se realiza para cada paquete dentro de cada release. Necesitamos vaciar las variables para volver a obtener los datos de los próximos paquetes.
		
		\begin{verbatim}
        	# Restablecer las listas y variables para el próximo paquete
			files_list = []
			package_list = []
			check_list = {}
			package = ""
			binary = ""
			version = ""
			maintainer = ""
			uploaders = ""
			build_depends = ""
			architecture = ""
			standards_version = ""
			format1 = ""
			vcs_browser = ""
			vcs_git = ""
			homepage = ""
			directory = ""
			priority = ""
			section = ""
			testsuite = ""
			testsuite_triggers = ""
		\end{verbatim}
		
\end{enumerate}

\section{Inserción de la información en la BBDD}
\label{sec:insercion_BBDD}
Una vez parseada la información de un paquete, debemos realizar la inserción en la BBDD. Esto se ejecuta mediante otro script en Pycharm y con la librería mysql.connector.

\begin{enumerate}
		\item \textbf{Conexión a la BBDD.} Primero debemos conectarnos a la BBDD para obtener la funcionalidad de insertar en ella. Debemos introducir los siguientes datos:
		\begin{verbatim}
			conexion = mysql.connector.connect(
			host='localhost',
			port=3306,
			user='root',
			password='xxxx',
			db='14.bookworm_main'
		)
		\end{verbatim} 
		
		\item \textbf{Creación de diccionario.} Necesitamos asociar los diferentes valores, de las variables de la sección ~\ref{sec:parseo}, a los nombres de las tablas para facilitar la lógica de dicho script.
		\begin{verbatim}
			datos = {
				"version": version,
				"maintainer": maintainer,
				"uploaders": uploaders,
				"build_depends": build_depends,
				"architecture": architecture,
				"standards_version": standards_version,
				"format": format1,
				"section": section,
				"priority": priority,
				...
		\end{verbatim} 
		
		\item \textbf{Inserción de los datos.} Finalmente pasamos a el objetivo final de este punto, la inserción. Tenemos varios casos que deben ser contemplados para su optima realización:
		
		\begin{itemize}
			\item \textbf{Valores vacíos:} en este caso debemos comprobar si la variable en cuestión tiene un valor predeterminado o viene vacío. Hay paquetes en los que no existen ciertas entidades como vimos en la sección ~\ref{sec:analisis_de_los_paquetes}. Se actualiza el valor a None para evitar fallos en la BBDD al insertar.
			
			\item \textbf{Datos duplicados: } hay entidades que se repiten en múltiples paquetes como las versiones o los maintainer. Debemos tener en cuenta que, al crear las tablas, se ponen restricciones como los identificadores únicos. Esto significa que no se pueden meter duplicados y por ello debemos tenerlo en cuenta. Para ello, buscamos si el valor ya se encuentra en la tabla, si se confirma, se ignora para evitar errores en las tablas SQL.
			
			\item \textbf{Valores múltiples: } hay entidades que tienen varios datos separados por comas como Build-Depends. En estos casos debemos separarlo por comas creando un array. Después, se recorre el array y se va metiendo uno a uno verificando que no sean duplicados.
			
			\begin{figure}[h]
				\centering
				\includegraphics[width=15cm, keepaspectratio]{img/Build_depends.png}
				\caption{Build Depends}
				\label{fig:Build_depends}
			\end{figure}
			
			\item \textbf{Files o Checksums-Sha256: } son 2 casos en los que no tenemos comas y vienen varios datos por entidad. Cuando verifiquemos que una linea del paquete empieza por estos 2 casos debemos cambiar la lógica. Saltamos a las siguientes lineas guardando todos los datos en un array. Posteriormente se recorrerá y se insertarán en las diferentes tablas.
			
			\begin{figure}[h]
				\centering
				\includegraphics[width=15cm, keepaspectratio]{img/Files.png}
				\caption{Files}
				\label{fig:Files}
			\end{figure}
		\end{itemize}
		
		Por último, hay que vincular diferentes tablas a través de sus foreing keys.
		
		Al insertar un paquete, guardamos su id. De esta forma, al insertar otra entidad diferente (en otra tabla) sabemos que id de paquete tiene y con ello podemos referenciarlo sin problemas.
		
		Esto es de suma importancia debido al diseño de las posteriores Query's.
\end{enumerate}

\section{Creación de Query´s SQL}
\label{sec:querys}

Para este proceso se necesita de nuevo un script en Pycharm que se conecte a la BBDD y, a través de lenguaje SQL, realice llamadas especificas a la misma. De esta forma obtendremos la información que se necesita.

\begin{enumerate}
	\item \textbf{Conexión a la BBDD.} Primero debemos conectarnos a la BBDD para obtener la funcionalidad de realizar llamadas sobre ella como en la sección ~\ref{sec:insercion_BBDD}.
	
	\item \textbf{Lenguaje de manipulación de datos~\cite{geotalleres:_sql}.} Proporcionado por el sistema de gestión de base de datos, permite a los usuarios llevar a cabo las tareas de consulta o manipulación de los datos, organizados por el modelo de datos adecuado. 

	\begin{itemize}
		\item \textbf{Comandos}: para insertar como en la sección ~\ref{sec:insercion_BBDD}, actualizar o borrar pero en este caso se quiere consultar por lo que usaremos "SELECT".
		
		\item \textbf{Clausulas}: son condiciones de modificación utilizadas para definir los datos que desea seleccionar o manipular. En nuestro caso usaremos "WHERE".
		
		\item \textbf{Operadores Lógicos}: como \textbf{AND, OR y NOT}.
		
		\item \textbf{Operadores de comparación}: como \textbf{LIKE, IN, BETWEEN, etc.}
		
	\end{itemize}
	
	\item \textbf{Query's.} Se crean diferentes funciones para separar las llamadas y facilitar la comprensión del código. 
	
	
	
	Este sería un ejemplo de una Query que devuelve el numero de mantainers total que hay en cada release o BBDD:
	
	\begin{verbatim}
		...
		consulta = "SELECT COUNT(*) FROM maintainer"
		cursor.execute(consulta)
		...
	\end{verbatim} 
	
	Cuenta el número de mantenedores que hay en la tabla 'maintainer' de la base de datos actual. Esta consulta va dentro de un bucle que hace el cálculo para todas las BBDD.
	
	Cada llamada contesta a las preguntas realizadas para este estudio obteniendo de forma eficiente la información de las BBDD.
	 
\end{enumerate}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% EXPERIMENTOS Y VALIDACIÓN %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Experimentos y validación}
\label{chap:experimentos}

Este capítulo se introdujo como requisito en 2019. 
Describe los experimentos y casos de test que tuviste que implementar para validar tus resultados. 
Incluye también los resultados de validación que permiten afirmar que tus resultados son correctos. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% RESULTADOS %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Resultados}
\label{chap:resultados}

En este capítulo se incluyen los resultados de tu trabajo fin de grado.

Si es una herramienta de análisis lo que has realizado, aquí puedes poner ejemplos de haberla utilizado para que se vea su utilidad.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CONCLUSIONES %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Conclusiones}
\label{chap:conclusiones}


\section{Consecución de objetivos}
\label{sec:consecucion-objetivos}

Esta sección es la sección espejo de las dos primeras del capítulo de objetivos, donde se planteaba el objetivo general y se elaboraban los específicos.

Es aquí donde hay que debatir qué se ha conseguido y qué no. 
Cuando algo no se ha conseguido, se ha de justificar, en términos de qué problemas se han encontrado y qué medidas se han tomado para mitigar esos problemas.

Y si has llegado hasta aquí, siempre es bueno pasarle el corrector ortográfico, que las erratas quedan fatal en la memoria final.
Para eso, en Linux tenemos aspell, que se ejecuta de la siguiente manera desde la línea de \emph{shell}:

\begin{verbatim}
  aspell --lang=es_ES -c memoria.tex
\end{verbatim}

\section{Aplicación de lo aprendido}
\label{sec:aplicacion}

Aquí viene lo que has aprendido durante el Grado/Máster y que has aplicado en el TFG/TFM.
Una buena idea es poner las asignaturas más relacionadas y comentar en un párrafo los conocimientos y habilidades puestos en práctica.

\begin{enumerate}
  \item a
  \item b
\end{enumerate}


\section{Lecciones aprendidas}
\label{sec:lecciones_aprendidas}

Aquí viene lo que has aprendido en el Trabajo Fin de Grado/Máster.

\begin{enumerate}
  \item Aquí viene uno.
  \item Aquí viene otro.
\end{enumerate}


\section{Trabajos futuros}
\label{sec:trabajos_futuros}

Ningún proyecto ni software se termina, así que aquí vienen ideas y funcionalidades que estaría bien tener implementadas en el futuro.

Es un apartado que sirve para dar ideas de cara a futuros TFGs/TFMs.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% APÉNDICE(S) %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\appendix
\chapter{Manual de usuario}
\label{app:manual}

Esto es un apéndice.
Si has creado una aplicación, siempre viene bien tener un manual de usuario.
Pues ponlo aquí.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BIBLIOGRAFIA %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage

% Las siguientes dos instrucciones es todo lo que necesitas
% para incluir las citas en la memoria
\bibliographystyle{abbrv}
\bibliography{memoria}  % memoria.bib es el nombre del fichero que contiene
% las referencias bibliográficas. Abre ese fichero y mira el formato que tiene,
% que se conoce como BibTeX. Hay muchos sitios que exportan referencias en
% formato BibTeX. Prueba a buscar en http://scholar.google.com por referencias
% y verás que lo puedes hacer de manera sencilla.
% Más información: 
% http://texblog.org/2014/04/22/using-google-scholar-to-download-bibtex-citations/

\end{document}
